<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Lamar City</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/three@0.137.5/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.5/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.137.5/examples/js/controls/OrbitControls.js"></script>
  </head>
  <body>
    <script>
      let scene, camera, renderer, controls;
      let dirLight, ambient;

      init();
      animate();

      function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xb7b8ca);

        // Camera
        const fov = 45;
        const aspect = window.innerWidth / window.innerHeight;
        const near = 0.1;
        const far = 10000;
        camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.set(300, 300, 300);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // ðŸ”¹ enable shadows
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        document.body.appendChild(renderer.domElement);

        const hemi = new THREE.HemisphereLight(0xffffff, 0x777777, 0.3);
        scene.add(hemi);

        // Lights
        ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(500, 1000, 500);
        dirLight.castShadow = true;

        dirLight.shadow.mapSize.set(2048, 2048);
        scene.add(dirLight);

        //renderer.outputEncoding = THREE.sRGBEncoding;
scene.fog = new THREE.Fog(0xb7b8ca, 800, 1800);

        ambient.intensity = 0.45;
        hemi.intensity = 0.25;
        dirLight.intensity = 0.9;

        dirLight.color.set(0xf4f6ff); // very subtle cool tint
        ambient.color.set(0xf0f2ff);
        // OrbitControls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.05;
        controls.screenSpacePanning = false;
        controls.enablePan = true;

        // Load GLB city
        const loader = new THREE.GLTFLoader();
        loader.load("/public/lamar-city.glb", function (gltf) {
          const root = gltf.scene;
          scene.add(root);

          // Put all city meshes on default layer
          root.traverse((obj) => {
            if (obj.isMesh) {
              obj.layers.set(0);
            }
          });

          // Hide original ground and standardize material
          root.traverse((obj) => {
            if (!obj.isMesh) return;

            const name = (obj.name || "").toLowerCase();

            // 1) hide original ground
            if (
              name.includes("ground") ||
              name.includes("plane") ||
              name.includes("floor") ||
              name.includes("terrain")
            ) {
              obj.visible = false;
              return;
            }

            // 2) special material for building lights (windows etc.)
            if (name.includes("buildings_lights")) {
              console.log("Using emissive lights on:", name);

              obj.material = new THREE.MeshStandardMaterial({
                color: 0x111111, // dark base so the glow stands out
                emissive: new THREE.Color(0xffc766), // warm but not too pale
                emissiveIntensity: 0.25,
                metalness: 0,
                roughness: 0.4,
              });

              obj.castShadow = false;
              obj.receiveShadow = false;
              return;
            }

            // 3) regular building material
            obj.material = new THREE.MeshStandardMaterial({
              color: 0xb0b4c3, // softer grey-blue, NOT white
              metalness: 0,
              roughness: 0.9, // very matte, like the reference
            });
          });

          const cityBoxBefore = getCityBoundingBox(root);
          console.log(
            "City size BEFORE scale:",
            cityBoxBefore.getSize(new THREE.Vector3())
          );

          autoScaleToSize(root, cityBoxBefore, 500);

          const cityBox = getCityBoundingBox(root);
          console.log(
            "City size AFTER scale:",
            cityBox.getSize(new THREE.Vector3())
          );

          addCustomGroundPlane(cityBox);

          root.traverse((obj) => {
            if (!obj.isMesh) return;

            const name = (obj.name || "").toLowerCase();

            if (name === "office_building" || name === "hotel") {
              //addBuildingInteriorLight(obj);
            }
          });
          // ðŸ”¹ Make buildings cast shadows
          root.traverse((obj) => {
            if (obj.isMesh) {
              obj.castShadow = true;
              obj.receiveShadow = false;
            }
          });

          // ðŸ”¹ Configure directional light's shadow camera around city
          const size = cityBox.getSize(new THREE.Vector3());
          const center = cityBox.getCenter(new THREE.Vector3());
          const maxXZ = Math.max(size.x, size.z);
          const half = maxXZ * 0.6;

          dirLight.position.set(
            center.x + maxXZ,
            center.y + maxXZ,
            center.z + maxXZ
          );
          dirLight.target.position.copy(center);
          scene.add(dirLight.target);

          const cam = dirLight.shadow.camera;
          cam.left = -half;
          cam.right = half;
          cam.top = half;
          cam.bottom = -half;
          cam.near = 0.1;
          cam.far = maxXZ * 4;
          cam.updateProjectionMatrix();

          // Frame camera based on city-only box
          frameObjectWithBox(root, cityBox, camera, controls, 1.2);
        });

        window.addEventListener("resize", onWindowResize, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function getCityBoundingBox(object) {
        const box = new THREE.Box3();
        const tempBox = new THREE.Box3();
        let hasNonGround = false;

        object.traverse((child) => {
          if (child.isMesh) {
            const name = (child.name || "").toLowerCase();
            const looksLikeGround =
              name.includes("ground") ||
              name.includes("plane") ||
              name.includes("floor") ||
              name.includes("terrain");

            if (looksLikeGround) return;

            child.updateWorldMatrix(true, false);
            tempBox.setFromObject(child);
            box.union(tempBox);
            hasNonGround = true;
          }
        });

        if (!hasNonGround) {
          box.setFromObject(object);
        }

        return box;
      }

      function autoScaleToSize(object, box, targetSize) {
        const size = box.getSize(new THREE.Vector3());
        const maxSize = Math.max(size.x, size.y, size.z);
        if (maxSize === 0) return;
        const scale = targetSize / maxSize;
        object.scale.setScalar(scale);
        object.updateMatrixWorld(true);
      }

      function frameObjectWithBox(
        object,
        box,
        camera,
        controls,
        fitOffset = 1.2
      ) {
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const maxSize = Math.max(size.x, size.y, size.z);

        const fitHeightDistance =
          maxSize / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2));
        const fitWidthDistance = fitHeightDistance / camera.aspect;
        const distance =
          fitOffset * Math.max(fitHeightDistance, fitWidthDistance);

        const dir = new THREE.Vector3(1, 1, 1).normalize();
        camera.position.copy(center).add(dir.multiplyScalar(distance));

        camera.near = Math.max(maxSize / 1000, 0.1);
        camera.far = maxSize * 100;
        camera.updateProjectionMatrix();

        const target = center.clone();
        target.y = box.min.y;
        controls.target.copy(target);
        controls.minDistance = maxSize * 0.1;
        controls.maxDistance = maxSize * 10;
        controls.update();
      }

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      function addCustomGroundPlane(box) {
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const maxXZ = Math.max(size.x, size.z);

        const planeGeo = new THREE.PlaneGeometry(maxXZ * 2, maxXZ * 2);
        const planeMat = new THREE.MeshStandardMaterial({
          color: 0x888a9c,
          roughness: 0.9,
          metalness: 0,
        });

        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.set(center.x, box.min.y + 40, center.z);

        plane.receiveShadow = true;
        plane.castShadow = false;

        scene.add(plane);
      }

      function addBuildingInteriorLight(mesh, color = 0xffc766) {
        const box = new THREE.Box3().setFromObject(mesh);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());
        const maxSize = Math.max(size.x, size.y, size.z) || 10;

        const light = new THREE.PointLight(color, 0.5, maxSize * 5, 2);
        const outward = size.x * 0.25; // 25% outward from center
light.position.set(
  center.x + outward,
  box.min.y + 5,
  center.z + outward
);
        light.castShadow = false; // keep global sun shadows only (cleaner)

        scene.add(light);

        // ðŸ” Debug helper so you can see where the light is
        const helper = new THREE.PointLightHelper(light, maxSize * 0.3);
        scene.add(helper);

        console.log("Added interior light for:", mesh.name, {
          pos: light.position,
          radius: maxSize * 4,
        });
      }

      function debugWireframeMesh(root, nameSubstring) {
        const target = nameSubstring.toLowerCase();

        root.traverse((obj) => {
          if (!obj.isMesh) return;

          const name = (obj.name || "").toLowerCase();

          // Show only meshes whose name contains the substring
          const isTarget = name.includes(target);
          obj.visible = isTarget;

          if (isTarget) {
            console.log("Debugging mesh:", obj.name, obj.geometry);

            obj.material = new THREE.MeshBasicMaterial({
              color: 0xff00ff,
              wireframe: true,
            });
          }
        });
      }
    </script>
  </body>
</html>
